{
    "sourceFile": "src/components/FFmpegPanel/components/TemplateManagementModal.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748094754346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748094754346,
            "name": "Commit-0",
            "content": "import { Alert, Button, Input, List, Modal, Popconfirm, Space } from \"antd\";\r\n\r\nimport { FFmpegTemplate } from \"../types\";\r\nimport React from \"react\";\r\n\r\ninterface TemplateManagementModalProps {\r\n  modalOpen: boolean;\r\n  setModalOpen: (open: boolean) => void;\r\n  templates: FFmpegTemplate[];\r\n  editingTemplateId: string | null;\r\n  newTplName: string;\r\n  setNewTplName: (name: string) => void;\r\n  handleCreateTemplate: () => void;\r\n  handleUpdateTemplate: () => void;\r\n  handleOpenRenameModal: (tpl: { id: string; name: string }) => void;\r\n  deleteTemplate: (id: string) => void;\r\n  applyTemplate: (id: string) => void;\r\n  isSaveDisabled: boolean; // 新增 prop，用于控制新建/更新按钮的disabled状态\r\n}\r\n\r\nconst TemplateManagementModal: React.FC<TemplateManagementModalProps> = ({\r\n  modalOpen,\r\n  setModalOpen,\r\n  templates,\r\n  editingTemplateId,\r\n  newTplName,\r\n  setNewTplName,\r\n  handleCreateTemplate,\r\n  handleUpdateTemplate,\r\n  handleOpenRenameModal,\r\n  deleteTemplate,\r\n  applyTemplate,\r\n  isSaveDisabled,\r\n}) => {\r\n  return (\r\n    <Modal\r\n      title=\"模板管理\"\r\n      open={modalOpen}\r\n      onCancel={() => {\r\n        setModalOpen(false);\r\n        // 模态框关闭时，如果不在编辑模式，清空编辑模板ID\r\n        if (!editingTemplateId) {\r\n          // setEditingTemplateId(null); // 这个状态的管理现在由 useTemplateManagement 负责\r\n        } else {\r\n          // 如果在编辑模式下关闭模态框，用户可能取消了更新，问询用户是否保留编辑状态或放弃\r\n          // 为了简化，暂时不处理，用户下次打开模态框时，editingTemplateId 依然存在\r\n        }\r\n      }}\r\n      footer={null}\r\n    >\r\n      <div style={{ marginBottom: 16 }}>\r\n        {/* 如果在编辑模式，显示更新提示和按钮 */}\r\n        {editingTemplateId ? (\r\n          <Alert\r\n            message={`正在编辑模板：${\r\n              templates.find((tpl) => tpl.id === editingTemplateId)?.name ||\r\n              \"未知模板\"\r\n            }`}\r\n            type=\"info\"\r\n            showIcon\r\n            style={{ marginBottom: 16 }}\r\n          />\r\n        ) : (\r\n          // 如果不在编辑模式，显示新建输入框和按钮\r\n          <Space>\r\n            <Input\r\n              placeholder=\"新模板名称\"\r\n              value={newTplName}\r\n              onChange={(e) => setNewTplName(e.target.value)}\r\n              style={{ width: 200 }}\r\n              onPressEnter={handleCreateTemplate}\r\n            />\r\n            <Button\r\n              type=\"primary\"\r\n              onClick={handleCreateTemplate}\r\n              disabled={isSaveDisabled} // 使用传入的 prop\r\n            >\r\n              新建模板\r\n            </Button>\r\n          </Space>\r\n        )}\r\n        {/* 无论是否在编辑模式，如果当前有选中操作，都可以选择更新当前正在编辑的模板 */}\r\n        {/* 注意：这里简化处理，即使editingTemplateId为空，也可以显示更新按钮，点击后提示用户需要先选择一个模板编辑 */}\r\n        {editingTemplateId && ( // 只在编辑模式下显示更新按钮\r\n          <Button\r\n            type=\"primary\"\r\n            onClick={handleUpdateTemplate}\r\n            style={{ marginLeft: 8 }}\r\n            disabled={isSaveDisabled} // 使用传入的 prop\r\n          >\r\n            更新模板\r\n          </Button>\r\n        )}\r\n      </div>\r\n      <List\r\n        bordered\r\n        dataSource={templates}\r\n        renderItem={(tpl) => (\r\n          <List.Item\r\n            actions={[\r\n              // 应用模板按钮\r\n              <Button\r\n                key=\"apply\"\r\n                size=\"small\"\r\n                type=\"link\"\r\n                onClick={() => {\r\n                  applyTemplate(tpl.id);\r\n                  setModalOpen(false); // Close modal after applying\r\n                  // setEditingTemplateId(null); // 这个状态的管理现在由 useTemplateManagement 负责\r\n                }}\r\n              >\r\n                应用\r\n              </Button>,\r\n              // 编辑按钮\r\n              <Button\r\n                key=\"edit\"\r\n                size=\"small\"\r\n                type=\"link\"\r\n                onClick={() => {\r\n                  applyTemplate(tpl.id); // 应用模板内容到主面板\r\n                  // setEditingTemplateId(tpl.id); // 这个状态的管理现在由 useTemplateManagement 负责\r\n                  setModalOpen(false); // 关闭模态框\r\n                }}\r\n              >\r\n                编辑\r\n              </Button>,\r\n              // 重命名操作 - 改为打开模态框\r\n              <Button\r\n                key={`rename-${tpl.id}`}\r\n                size=\"small\"\r\n                onClick={() => handleOpenRenameModal(tpl)} // 点击打开重命名模态框\r\n              >\r\n                重命名\r\n              </Button>,\r\n              // 删除操作\r\n              <Popconfirm\r\n                key={`delete-${tpl.id}`}\r\n                title=\"确定删除该模板？\"\r\n                onConfirm={() => deleteTemplate(tpl.id)}\r\n              >\r\n                <Button size=\"small\" danger>\r\n                  删除\r\n                </Button>\r\n              </Popconfirm>,\r\n            ]}\r\n          >\r\n            <div\r\n              style={{\r\n                flex: 1,\r\n                overflow: \"hidden\",\r\n                textOverflow: \"ellipsis\",\r\n                whiteSpace: \"nowrap\",\r\n              }}\r\n            >\r\n              {tpl.name}\r\n            </div>\r\n          </List.Item>\r\n        )}\r\n        locale={{ emptyText: \"暂无模板\" }}\r\n      />\r\n    </Modal>\r\n  );\r\n};\r\n\r\nexport default TemplateManagementModal;\r\n"
        }
    ]
}