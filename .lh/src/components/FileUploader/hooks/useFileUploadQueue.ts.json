{
    "sourceFile": "src/components/FileUploader/hooks/useFileUploadQueue.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1748066189083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748066215910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n   calcFileMD5WithWorker,\n   calcSpeedAndLeftTime,\n   calcTotalSpeed,\n   checkFileBeforeUpload,\n-  checkFileType,\n+  checkFileTypeSafe,\n   createFileChunks,\n } from \"../utils\";\n import {\n   checkInstantUpload,\n@@ -143,9 +143,9 @@\n    */\n   const handleBeforeUpload = useCallback(\n     (file: File) => {\n       // 文件类型安全校验\n-      if (!checkFileType(file, allowedTypes)) {\n+      if (!checkFileTypeSafe(file, allowedTypes)) {\n         message.error(\"文件类型不被允许\");\n         return Upload.LIST_IGNORE;\n       }\n       const ok = checkFileBeforeUpload({\n"
                }
            ],
            "date": 1748066189083,
            "name": "Commit-0",
            "content": "import { Modal, Upload, message } from \"antd\";\nimport {\n  appendSpeedHistory,\n  calcFileMD5WithWorker,\n  calcSpeedAndLeftTime,\n  calcTotalSpeed,\n  checkFileBeforeUpload,\n  checkFileType,\n  createFileChunks,\n} from \"../utils\";\nimport {\n  checkInstantUpload,\n  getFileStatus,\n  mergeFile,\n  uploadFileChunk,\n} from \"../api\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * 文件上传队列与主流程 Hook\n * 封装所有上传相关状态与操作，支持分片、秒传、进度、速率、错误等。\n * @param options.accept 支持的文件类型（如 .png,.jpg,image/*）\n * @param options.maxSizeMB 最大文件大小（MB）\n * @param options.multiple 是否多文件上传（未用到，可忽略）\n * @param options.concurrency 并发上传数\n * @param options.chunkSize 分片大小（字节）\n * @param options.uploadUrl 上传接口URL\n * @param options.checkUrl 秒传接口URL\n * @param options.mergeUrl 合并接口URL\n * @param options.headers 请求头\n * @param options.paramsTransform 参数转换函数\n * @param options.onSuccess 上传成功回调\n * @param options.onError 上传错误回调\n * @param options.onProgress 上传进度回调\n * @param options.onMergeSuccess 合并成功回调\n * @param options.onCheckSuccess 秒传成功回调\n * @param options.maxRetry 最大重试次数\n * @param options.keepAfterUpload 上传完成后是否保留文件\n * @param options.removeDelayMs 上传完成后延时移除文件的毫秒数\n * @param options.onRemoveAfterUpload 上传完成后移除文件的回调\n * @param options.allowedTypes 允许的文件类型\n * @param options.apiPrefix 接口前缀\n * @returns 所有上传相关状态与操作方法\n */\nexport function useFileUploadQueue({\n  accept = \"*\",\n  maxSizeMB = 2048,\n  concurrency = 3,\n  chunkSize = 2 * 1024 * 1024,\n  uploadUrl,\n  checkUrl,\n  mergeUrl,\n  headers,\n  paramsTransform,\n  onSuccess,\n  onError,\n  onProgress,\n  onMergeSuccess,\n  onCheckSuccess,\n  maxRetry = 3,\n  keepAfterUpload = true,\n  removeDelayMs = 2000,\n  onRemoveAfterUpload,\n  allowedTypes = [\"image/png\", \"image/jpeg\", \"image/gif\"],\n  apiPrefix,\n}: {\n  accept?: string;\n  maxSizeMB?: number;\n  multiple?: boolean;\n  concurrency?: number;\n  chunkSize?: number;\n  uploadUrl?: string;\n  checkUrl?: string;\n  mergeUrl?: string;\n  headers?: Record<string, string>;\n  paramsTransform?: (params: any, type: string) => any;\n  onSuccess?: (file: File, res: any) => void;\n  onError?: (file: File, err: Error) => void;\n  onProgress?: (file: File, percent: number) => void;\n  onMergeSuccess?: (file: File, res: any) => void;\n  onCheckSuccess?: (file: File, res: any) => void;\n  maxRetry?: number;\n  keepAfterUpload?: boolean;\n  removeDelayMs?: number;\n  onRemoveAfterUpload?: (\n    file: File,\n    reason: \"upload\" | \"instant\"\n  ) => boolean | void | Promise<boolean | void>;\n  allowedTypes?: string[];\n  apiPrefix?: string;\n}) {\n  /**\n   * 文件列表\n   */\n  const [files, setFiles] = useState<File[]>([]);\n  /**\n   * MD5 及分片MD5信息\n   */\n  const [md5Info, setMd5Info] = useState<\n    Record<string, { fileMD5: string; chunkMD5s: string[] }>\n  >({});\n  /**\n   * 秒传/分片存在性信息\n   */\n  const [instantInfo, setInstantInfo] = useState<\n    Record<string, { uploaded: boolean; chunkCheckResult: any[] }>\n  >({});\n  /**\n   * 上传进度与状态\n   */\n  const [uploadingInfo, setUploadingInfo] = useState<\n    Record<string, { progress: number; status: string }>\n  >({});\n  /**\n   * 当前 loading 文件 key\n   */\n  const [loadingKey, setLoadingKey] = useState<string | null>(null);\n  /**\n   * 批量上传中标记\n   */\n  const [uploadingAll, setUploadingAll] = useState(false);\n  /**\n   * 速率与剩余时间\n   */\n  const [speedInfo, setSpeedInfo] = useState<\n    Record<string, { speed: number; leftTime: number }>\n  >({});\n  /**\n   * 速率滑动窗口历史\n   */\n  const speedHistoryRef = useRef<\n    Record<string, Array<{ time: number; loaded: number }>>\n  >({});\n  /**\n   * 错误信息\n   */\n  const [errorInfo, setErrorInfo] = useState<Record<string, string>>({});\n\n  /**\n   * beforeUpload 校验\n   * @param file 文件对象\n   * @returns 是否允许上传\n   */\n  const handleBeforeUpload = useCallback(\n    (file: File) => {\n      // 文件类型安全校验\n      if (!checkFileType(file, allowedTypes)) {\n        message.error(\"文件类型不被允许\");\n        return Upload.LIST_IGNORE;\n      }\n      const ok = checkFileBeforeUpload({\n        file,\n        accept,\n        maxSizeMB,\n        onError: (msg) => message.error(msg),\n      });\n      if (!ok) return Upload.LIST_IGNORE;\n      setFiles((prev) => {\n        if (prev.find((f) => f.name === file.name && f.size === file.size))\n          return prev;\n        return [...prev, file];\n      });\n      return false; // 阻止自动上传\n    },\n    [accept, maxSizeMB, allowedTypes]\n  );\n\n  /**\n   * 计算MD5并秒传验证\n   * @param file 文件对象\n   */\n  const handleCalcMD5 = useCallback(\n    async (file: File) => {\n      setLoadingKey(file.name + file.size);\n      try {\n        const result = await calcFileMD5WithWorker(file, chunkSize);\n        setMd5Info((prev) => ({ ...prev, [file.name + file.size]: result }));\n        // message.success(`MD5计算完成: ${result.fileMD5}`);\n        // 秒传验证\n        const fileId = `${result.fileMD5}-${file.name}-${file.size}`;\n        const chunks = createFileChunks(file, chunkSize);\n        const instantRes = await checkInstantUpload(\n          {\n            fileId,\n            md5: result.fileMD5,\n            name: file.name,\n            size: file.size,\n            total: chunks.length,\n            chunkMD5s: result.chunkMD5s,\n          },\n          {\n            url: checkUrl,\n            apiPrefix,\n            headers,\n            paramsTransform,\n          }\n        );\n        if (onCheckSuccess) onCheckSuccess(file, instantRes);\n        setInstantInfo((prev) => ({\n          ...prev,\n          [file.name + file.size]: instantRes,\n        }));\n        // 秒传成功也受keepAfterUpload控制\n        if (instantRes.uploaded && !keepAfterUpload) {\n          setTimeout(async () => {\n            let shouldRemove = true;\n            if (onRemoveAfterUpload) {\n              const ret = await onRemoveAfterUpload(file, \"instant\");\n              if (ret === false) shouldRemove = false;\n            }\n            if (shouldRemove) {\n              setFiles((prev) =>\n                prev.filter((f) => f.name + f.size !== file.name + file.size)\n              );\n            }\n          }, removeDelayMs);\n        }\n      } catch {\n        // message.error(\"MD5或秒传接口异常\");\n      } finally {\n        setLoadingKey(null);\n      }\n    },\n    [\n      chunkSize,\n      checkUrl,\n      headers,\n      paramsTransform,\n      onCheckSuccess,\n      keepAfterUpload,\n      removeDelayMs,\n      onRemoveAfterUpload,\n      apiPrefix,\n    ]\n  );\n\n  // 找到所有未计算MD5的文件，依次自动计算\n  useEffect(() => {\n    const unMd5Files = files.filter((f) => !md5Info[f.name + f.size]);\n    if (unMd5Files.length > 0 && !loadingKey) {\n      (async () => {\n        for (const file of unMd5Files) {\n          await handleCalcMD5(file);\n        }\n      })();\n    }\n  }, [files, md5Info, loadingKey, handleCalcMD5]);\n\n  // 分片上传主流程\n  const handleStartUpload = useCallback(\n    async (file: File, resumeInfo?: any) => {\n      const key = file.name + file.size;\n      setErrorInfo((prev) => ({ ...prev, [key]: \"\" }));\n      const md5 = md5Info[key]?.fileMD5 || resumeInfo?.md5;\n\n      if (!md5) {\n        return;\n      }\n\n      const fileId = `${md5}-${file.name}-${file.size}`;\n\n      let uploadedChunks: number[] = resumeInfo?.uploadedChunks || [];\n      if (!resumeInfo) {\n        try {\n          uploadedChunks = await getFileStatus({ fileId, md5 }, { apiPrefix });\n        } catch (err) {\n          console.log(err);\n          // 忽略错误，继续执行\n        }\n      }\n\n      const allChunks = createFileChunks(file, chunkSize);\n      const needUploadChunks = allChunks.filter(\n        (c) => !uploadedChunks.includes(c.index)\n      );\n\n      let uploadedCount = uploadedChunks.length;\n      let uploadedBytes = uploadedChunks.reduce(\n        (sum, idx) =>\n          sum +\n          (createFileChunks(file, chunkSize)[idx]?.end -\n            createFileChunks(file, chunkSize)[idx]?.start),\n        0\n      );\n\n      setUploadingInfo((prev) => ({\n        ...prev,\n        [key]: {\n          progress: Math.round((uploadedCount / allChunks.length) * 100),\n          status: \"uploading\",\n        },\n      }));\n\n      speedHistoryRef.current[key] = [\n        { time: Date.now(), loaded: uploadedBytes },\n      ];\n\n      // 上传每个分片\n      for (const chunk of needUploadChunks) {\n        let retry = 0;\n        let delay = 500;\n        const chunkSizeVal = chunk.end - chunk.start;\n\n        while (retry < maxRetry) {\n          try {\n            const uploadResult = await uploadFileChunk(\n              {\n                fileId,\n                chunk_md5: md5Info[key].chunkMD5s[chunk.index],\n                index: chunk.index,\n                chunk: chunk.chunk,\n                name: file.name,\n                total: allChunks.length,\n              },\n              {\n                url: uploadUrl,\n                apiPrefix,\n                headers,\n                paramsTransform,\n              }\n            );\n\n            // 使用服务器返回的MD5值更新本地状态\n            if (uploadResult.data?.chunk_md5) {\n              md5Info[key].chunkMD5s[chunk.index] = uploadResult.data.chunk_md5;\n            }\n\n            uploadedCount++;\n            uploadedBytes += chunkSizeVal;\n            uploadedChunks.push(chunk.index);\n\n            // 更新进度\n            const progress = Math.round(\n              (uploadedCount / allChunks.length) * 100\n            );\n\n            setUploadingInfo((prev) => ({\n              ...prev,\n              [key]: {\n                progress,\n                status: \"uploading\",\n              },\n            }));\n\n            // 更新速度信息\n            const now = Date.now();\n            const prevHistory = speedHistoryRef.current[key] || [];\n            speedHistoryRef.current[key] = appendSpeedHistory(\n              prevHistory,\n              now,\n              uploadedBytes,\n              5\n            );\n            const history = speedHistoryRef.current[key];\n            if (history.length >= 2) {\n              const { speed, leftTime } = calcSpeedAndLeftTime(\n                history,\n                file.size\n              );\n              setSpeedInfo((prev) => ({\n                ...prev,\n                [key]: {\n                  speed,\n                  leftTime,\n                },\n              }));\n            }\n\n            if (onProgress) {\n              onProgress(file, progress);\n            }\n            break;\n          } catch (err: any) {\n            retry++;\n            if (retry >= maxRetry) {\n              setUploadingInfo((prev) => ({\n                ...prev,\n                [key]: {\n                  progress: Math.round(\n                    (uploadedCount / allChunks.length) * 100\n                  ),\n                  status: \"error\",\n                },\n              }));\n              setErrorInfo((prev) => ({\n                ...prev,\n                [key]: err?.message || \"分片上传失败\",\n              }));\n              return;\n            }\n            await new Promise((res) => setTimeout(res, delay));\n            delay = Math.min(delay * 2, 5000);\n          }\n        }\n      }\n\n      // 所有分片上传完成，开始合并\n      try {\n        const mergeResult = await mergeFile(\n          {\n            fileId,\n            md5,\n            name: file.name,\n            size: file.size,\n            total: allChunks.length,\n          },\n          {\n            url: mergeUrl,\n            apiPrefix,\n            headers,\n            paramsTransform,\n          }\n        );\n\n        setUploadingInfo((prev) => ({\n          ...prev,\n          [key]: { progress: 100, status: \"done\" },\n        }));\n        setSpeedInfo((prev) => ({ ...prev, [key]: { speed: 0, leftTime: 0 } }));\n        setErrorInfo((prev) => ({ ...prev, [key]: \"\" }));\n\n        if (onMergeSuccess) onMergeSuccess(file, mergeResult);\n        if (onSuccess) onSuccess(file, mergeResult);\n\n        // 自动移除已上传文件\n        if (!keepAfterUpload) {\n          setTimeout(async () => {\n            let shouldRemove = true;\n            if (onRemoveAfterUpload) {\n              const ret = await onRemoveAfterUpload(file, \"upload\");\n              if (ret === false) shouldRemove = false;\n            }\n            if (shouldRemove) {\n              setFiles((prev) => prev.filter((f) => f.name + f.size !== key));\n            }\n          }, removeDelayMs);\n        }\n      } catch (err: any) {\n        setUploadingInfo((prev) => ({\n          ...prev,\n          [key]: { progress: 100, status: \"merge-error\" },\n        }));\n        setErrorInfo((prev) => ({\n          ...prev,\n          [key]: err?.message || \"合并失败\",\n        }));\n        if (onError) onError(file, err);\n        Modal.error({\n          title: \"合并失败\",\n          content: err?.message || \"合并失败\",\n        });\n      }\n    },\n    [\n      md5Info,\n      chunkSize,\n      uploadUrl,\n      checkUrl,\n      mergeUrl,\n      headers,\n      paramsTransform,\n      onSuccess,\n      onError,\n      onProgress,\n      onMergeSuccess,\n      maxRetry,\n      keepAfterUpload,\n      removeDelayMs,\n      onRemoveAfterUpload,\n      apiPrefix,\n    ]\n  );\n\n  // 重试单个文件\n  const handleRetry = useCallback(\n    (file: File) => {\n      handleStartUpload(file);\n    },\n    [handleStartUpload]\n  );\n\n  // 重试所有失败文件\n  const handleRetryAllFailed = useCallback(async () => {\n    const failedFiles = files.filter((file) => {\n      const key = file.name + file.size;\n      const uploading = uploadingInfo[key];\n      return (\n        uploading &&\n        (uploading.status === \"error\" || uploading.status === \"merge-error\")\n      );\n    });\n    for (const file of failedFiles) {\n      await handleStartUpload(file);\n    }\n    // message.success(\"所有失败文件已重试\");\n  }, [files, uploadingInfo, handleStartUpload]);\n\n  // 批量上传自动补齐MD5\n  const handleStartAll = useCallback(async () => {\n    setUploadingAll(true);\n    // 先为所有未计算MD5的文件自动计算MD5\n    for (const file of files) {\n      const key = file.name + file.size;\n      if (!md5Info[key]) {\n        await handleCalcMD5(file);\n      }\n    }\n    // 过滤出未秒传且未上传完成的文件\n    const needUploadFiles = files.filter((file) => {\n      const key = file.name + file.size;\n      const instant = instantInfo[key];\n      const uploading = uploadingInfo[key];\n      return (\n        md5Info[key] &&\n        !instant?.uploaded &&\n        (!uploading || uploading.status !== \"done\")\n      );\n    });\n    // 并发控制\n    let idx = 0;\n    const queue: Promise<void>[] = [];\n    const next = async () => {\n      if (idx >= needUploadFiles.length) return;\n      const file = needUploadFiles[idx++];\n      await handleStartUpload(file);\n      await next();\n    };\n    for (let i = 0; i < Math.min(concurrency, needUploadFiles.length); i++) {\n      queue.push(next());\n    }\n    await Promise.all(queue);\n    setUploadingAll(false);\n    // message.success(\"全部上传任务已完成\");\n  }, [\n    files,\n    md5Info,\n    instantInfo,\n    uploadingInfo,\n    handleCalcMD5,\n    handleStartUpload,\n    concurrency,\n  ]);\n\n  // 单个文件上传按钮自动补齐MD5\n  const handleStartUploadWithAutoMD5 = useCallback(\n    async (file: File) => {\n      const key = file.name + file.size;\n      if (!md5Info[key]) {\n        await handleCalcMD5(file);\n      }\n      await handleStartUpload(file);\n    },\n    [md5Info, handleCalcMD5, handleStartUpload]\n  );\n\n  return {\n    files,\n    setFiles,\n    md5Info,\n    instantInfo,\n    uploadingInfo,\n    loadingKey,\n    uploadingAll,\n    speedInfo,\n    errorInfo,\n    handleBeforeUpload,\n    handleCalcMD5,\n    handleStartUpload,\n    handleStartAll,\n    handleRetry,\n    handleRetryAllFailed,\n    handleStartUploadWithAutoMD5,\n    calcTotalSpeed,\n  };\n}\n"
        }
    ]
}