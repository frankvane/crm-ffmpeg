{
    "sourceFile": "src/components/FileUploader/utils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748066177824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748066177824,
            "name": "Commit-0",
            "content": "// 上传相关工具函数\n\n/**\n * 校验文件类型和大小\n * @param params.file 文件对象\n * @param params.accept 支持的类型（如 .png,.jpg,image/*）\n * @param params.maxSizeMB 最大文件大小（MB）\n * @param params.onError 错误回调\n * @returns 是否通过校验\n */\nexport function checkFileBeforeUpload({\n  file,\n  accept,\n  maxSizeMB,\n  onError,\n}: {\n  file: File;\n  accept: string;\n  maxSizeMB: number;\n  onError: (msg: string) => void;\n}) {\n  const acceptList = accept.split(\",\").map((s) => s.trim().toLowerCase());\n  const fileExt = \".\" + file.name.split(\".\").pop()?.toLowerCase();\n  const fileType = file.type.toLowerCase();\n  // 类型校验\n  const typeOk =\n    acceptList.includes(\"*\") ||\n    acceptList.includes(fileExt) ||\n    (acceptList.includes(\"image/*\") && fileType.startsWith(\"image/\"));\n  if (!typeOk) {\n    onError(\"文件类型不支持\");\n    return false;\n  }\n  if (file.size > maxSizeMB * 1024 * 1024) {\n    onError(`文件不能超过${maxSizeMB}MB`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * 文件分片切割\n * @param file 文件对象\n * @param chunkSize 分片大小（字节）\n * @returns 分片数组\n */\nexport function createFileChunks(file: File, chunkSize: number) {\n  const chunks = [];\n  let cur = 0;\n  while (cur < file.size) {\n    chunks.push({\n      index: chunks.length,\n      start: cur,\n      end: Math.min(cur + chunkSize, file.size),\n      chunk: file.slice(cur, cur + chunkSize),\n    });\n    cur += chunkSize;\n  }\n  return chunks;\n}\n\n/**\n * 通过WebWorker计算文件MD5\n * @param file 文件对象\n * @param chunkSize 分片大小（字节）\n * @returns Promise<{ fileMD5: string; chunkMD5s: string[] }>\n */\nexport function calcFileMD5WithWorker(\n  file: File,\n  chunkSize: number\n): Promise<{ fileMD5: string; chunkMD5s: string[] }> {\n  return new Promise((resolve, reject) => {\n    // worker-md5.js 需后续补全\n    const worker = new Worker(new URL(\"./worker-md5.js\", import.meta.url));\n    worker.postMessage({ file, chunkSize });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n      worker.terminate();\n    };\n    worker.onerror = (err) => {\n      reject(err);\n      worker.terminate();\n    };\n  });\n}\n\n/**\n * 追加速率滑动窗口历史\n * @param history 现有历史数组\n * @param time 当前时间戳\n * @param loaded 当前已上传字节数\n * @param windowSize 滑动窗口大小\n * @returns 新的历史数组\n */\nexport function appendSpeedHistory(\n  history: Array<{ time: number; loaded: number }>,\n  time: number,\n  loaded: number,\n  windowSize: number\n) {\n  const newHistory = [...history, { time, loaded }];\n  if (newHistory.length > windowSize) newHistory.shift();\n  return newHistory;\n}\n\n/**\n * 计算速率和剩余时间\n * @param history 滑动窗口历史\n * @param fileSize 文件总大小\n * @returns { speed: number, leftTime: number }\n */\nexport function calcSpeedAndLeftTime(\n  history: Array<{ time: number; loaded: number }>,\n  fileSize: number\n) {\n  if (history.length < 2) return { speed: 0, leftTime: 0 };\n  const first = history[0];\n  const last = history[history.length - 1];\n  const speed =\n    (last.loaded - first.loaded) / ((last.time - first.time) / 1000); // B/s\n  const leftBytes = fileSize - last.loaded;\n  const leftTime = speed > 0 ? leftBytes / speed : 0;\n  return { speed, leftTime };\n}\n\n/**\n * 统计总速率\n * @param speedInfo 所有文件的速率信息\n * @returns 总速率（B/s）\n */\nexport function calcTotalSpeed(\n  speedInfo: Record<string, { speed: number; leftTime: number }>\n) {\n  return Object.values(speedInfo).reduce((sum, s) => sum + (s.speed || 0), 0);\n}\n\n/**\n * 字节数友好显示（自动转换为 KB/MB/GB，保留两位小数）\n * @param size 字节数\n * @returns 友好字符串\n */\nexport function ByteConvert(size: number): string {\n  if (size < 1024) return size + \" B\";\n  if (size < 1024 * 1024) return (size / 1024).toFixed(2) + \" KB\";\n  if (size < 1024 * 1024 * 1024) return (size / 1024 / 1024).toFixed(2) + \" MB\";\n  return (size / 1024 / 1024 / 1024).toFixed(2) + \" GB\";\n}\n\n/**\n * 检查文件类型\n * @param file 文件对象\n * @param allowedTypes 允许的MIME类型数组\n */\nexport function checkFileType(file: File, allowedTypes: string[]): boolean {\n  // 只用file.type判断\n  return allowedTypes.includes(file.type);\n}\n"
        }
    ]
}